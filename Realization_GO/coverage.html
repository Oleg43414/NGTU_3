
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>realization_go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">realization_go/doubly_linked_list.go (94.7%)</option>
				
				<option value="file1">realization_go/dynamic_array.go (89.2%)</option>
				
				<option value="file2">realization_go/full_binary_tree.go (84.9%)</option>
				
				<option value="file3">realization_go/hash.go (84.3%)</option>
				
				<option value="file4">realization_go/main.go (0.0%)</option>
				
				<option value="file5">realization_go/queue.go (96.3%)</option>
				
				<option value="file6">realization_go/singly_linked_list.go (95.3%)</option>
				
				<option value="file7">realization_go/stack.go (89.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "os"
        "strconv"
)

// DoublyNode - узел двусвязного списка
type DoublyNode struct {
        Key  int
        Next *DoublyNode
        Prev *DoublyNode
}

// DoublyLinkedList - двусвязный список
type DoublyLinkedList struct {
        Head *DoublyNode
        Tail *DoublyNode
}

// NewDoublyLinkedList - конструктор
func NewDoublyLinkedList() *DoublyLinkedList <span class="cov8" title="1">{
        return &amp;DoublyLinkedList{
                Head: nil,
                Tail: nil,
        }
}</span>

// createNode - создание нового узла
func (d *DoublyLinkedList) createNode(value int) *DoublyNode <span class="cov8" title="1">{
        return &amp;DoublyNode{
                Key:  value,
                Next: nil,
                Prev: nil,
        }
}</span>

// AddToHead - добавление в начало
func (d *DoublyLinkedList) AddToHead(value int) <span class="cov8" title="1">{
        newNode := d.createNode(value)

        if d.Head == nil </span><span class="cov8" title="1">{
                d.Head = newNode
                d.Tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.Next = d.Head
                d.Head.Prev = newNode
                d.Head = newNode
        }</span>
        <span class="cov8" title="1">fmt.Printf("Добавлен в начало списка: %d\n", value)</span>
}

// AddToTail - добавление в конец
func (d *DoublyLinkedList) AddToTail(value int) <span class="cov8" title="1">{
        newNode := d.createNode(value)

        if d.Tail == nil </span><span class="cov8" title="1">{
                d.Head = newNode
                d.Tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.Prev = d.Tail
                d.Tail.Next = newNode
                d.Tail = newNode
        }</span>
        <span class="cov8" title="1">fmt.Printf("Добавлен в конец списка: %d\n", value)</span>
}

// AddAfterValue - добавление после значения
func (d *DoublyLinkedList) AddAfterValue(targetValue, newValue int) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст! Невозможно добавить после значения.")
                return
        }</span>

        <span class="cov8" title="1">current := d.Head
        for current != nil &amp;&amp; current.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d не найден в списке!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">newNode := d.createNode(newValue)
        newNode.Next = current.Next
        newNode.Prev = current

        if current.Next != nil </span><span class="cov8" title="1">{
                current.Next.Prev = newNode
        }</span> else<span class="cov8" title="1"> {
                d.Tail = newNode
        }</span>

        <span class="cov8" title="1">current.Next = newNode
        fmt.Printf("Добавлен элемент %d после элемента %d\n", newValue, targetValue)</span>
}

// AddBeforeValue - добавление перед значением
func (d *DoublyLinkedList) AddBeforeValue(targetValue, newValue int) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст! Невозможно добавить перед значением.")
                return
        }</span>

        <span class="cov8" title="1">current := d.Head
        for current != nil &amp;&amp; current.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d не найден в списке!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">newNode := d.createNode(newValue)
        newNode.Prev = current.Prev
        newNode.Next = current

        if current.Prev != nil </span><span class="cov8" title="1">{
                current.Prev.Next = newNode
        }</span> else<span class="cov8" title="1"> {
                d.Head = newNode
        }</span>

        <span class="cov8" title="1">current.Prev = newNode
        fmt.Printf("Добавлен элемент %d перед элементом %d\n", newValue, targetValue)</span>
}

// DeleteFromHead - удаление из начала
func (d *DoublyLinkedList) DeleteFromHead() <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>

        <span class="cov8" title="1">temp := d.Head
        d.Head = d.Head.Next

        if d.Head != nil </span><span class="cov8" title="1">{
                d.Head.Prev = nil
        }</span> else<span class="cov8" title="1"> {
                d.Tail = nil
        }</span>

        <span class="cov8" title="1">fmt.Printf("Удален из начала: %d\n", temp.Key)</span>
}

// DeleteFromTail - удаление из конца
func (d *DoublyLinkedList) DeleteFromTail() <span class="cov8" title="1">{
        if d.Tail == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>

        <span class="cov8" title="1">temp := d.Tail
        d.Tail = d.Tail.Prev

        if d.Tail != nil </span><span class="cov8" title="1">{
                d.Tail.Next = nil
        }</span> else<span class="cov8" title="1"> {
                d.Head = nil
        }</span>

        <span class="cov8" title="1">fmt.Printf("Удален из конца: %d\n", temp.Key)</span>
}

// DeleteByValue - удаление по значению
func (d *DoublyLinkedList) DeleteByValue(value int) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>

        <span class="cov8" title="1">current := d.Head
        for current != nil &amp;&amp; current.Key != value </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov0" title="0">{
                fmt.Printf("Элемент %d не найден!\n", value)
                return
        }</span>

        <span class="cov8" title="1">if current.Prev != nil </span><span class="cov8" title="1">{
                current.Prev.Next = current.Next
        }</span> else<span class="cov8" title="1"> {
                d.Head = current.Next
        }</span>

        <span class="cov8" title="1">if current.Next != nil </span><span class="cov8" title="1">{
                current.Next.Prev = current.Prev
        }</span> else<span class="cov8" title="1"> {
                d.Tail = current.Prev
        }</span>

        <span class="cov8" title="1">fmt.Printf("Удален элемент: %d\n", current.Key)</span>
}

// DeleteAfterValue - удаление после значения
func (d *DoublyLinkedList) DeleteAfterValue(targetValue int) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст! Невозможно удалить элемент.")
                return
        }</span>

        <span class="cov8" title="1">current := d.Head
        for current != nil &amp;&amp; current.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d не найден в списке!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">if current.Next == nil </span><span class="cov8" title="1">{
                fmt.Printf("После элемента %d нет элементов для удаления!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">nodeToDelete := current.Next
        current.Next = nodeToDelete.Next

        if nodeToDelete.Next != nil </span><span class="cov8" title="1">{
                nodeToDelete.Next.Prev = current
        }</span> else<span class="cov8" title="1"> {
                d.Tail = current
        }</span>

        <span class="cov8" title="1">fmt.Printf("Удален элемент: %d после элемента %d\n", nodeToDelete.Key, targetValue)</span>
}

// DeleteBeforeValue - удаление перед значением
func (d *DoublyLinkedList) DeleteBeforeValue(targetValue int) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст! Невозможно удалить элемент.")
                return
        }</span>

        <span class="cov8" title="1">current := d.Head
        for current != nil &amp;&amp; current.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d не найден в списке!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">if current.Prev == nil </span><span class="cov8" title="1">{
                fmt.Printf("Перед элементом %d нет элементов для удаления!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">nodeToDelete := current.Prev
        current.Prev = nodeToDelete.Prev

        if nodeToDelete.Prev != nil </span><span class="cov8" title="1">{
                nodeToDelete.Prev.Next = current
        }</span> else<span class="cov8" title="1"> {
                d.Head = current
        }</span>

        <span class="cov8" title="1">fmt.Printf("Удален элемент: %d перед элементом %d\n", nodeToDelete.Key, targetValue)</span>
}

// FindByValue - поиск по значению
func (d *DoublyLinkedList) FindByValue(value int) bool <span class="cov8" title="1">{
        current := d.Head
        for current != nil </span><span class="cov8" title="1">{
                if current.Key == value </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return false</span>
}

// PrintForward - печать с начала в конец
func (d *DoublyLinkedList) PrintForward() <span class="cov8" title="1">{
        fmt.Print("Список (начало -&gt; конец): ")
        current := d.Head
        for current != nil </span><span class="cov8" title="1">{
                fmt.Printf("%d ", current.Key)
                current = current.Next
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// PrintBackward - печать с конца в начало
func (d *DoublyLinkedList) PrintBackward() <span class="cov8" title="1">{
        fmt.Print("Список (конец -&gt; начало): ")
        current := d.Tail
        for current != nil </span><span class="cov8" title="1">{
                fmt.Printf("%d ", current.Key)
                current = current.Prev
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// Clear - очистка списка
func (d *DoublyLinkedList) Clear() <span class="cov8" title="1">{
        d.Head = nil
        d.Tail = nil
        fmt.Println("Двусвязный список очищен")
}</span>

// SaveToFile - сохранение в текстовый файл
func (d *DoublyLinkedList) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка создания файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        current := d.Head
        for current != nil </span><span class="cov8" title="1">{
                _, err := fmt.Fprintf(file, "%d ", current.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">fmt.Printf("Двусвязный список сохранён в файл: %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (d *DoublyLinkedList) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        d.Clear()

        scanner := bufio.NewScanner(file)
        scanner.Split(bufio.ScanWords)

        for scanner.Scan() </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(scanner.Text())
                if err == nil </span><span class="cov8" title="1">{
                        d.AddToTail(value)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Двусвязный список загружен из файла: %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл
func (d *DoublyLinkedList) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка создания бинарного файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Подсчет количества элементов
        count := 0
        current := d.Head
        for current != nil </span><span class="cov8" title="1">{
                count++
                current = current.Next
        }</span>

        // Запись количества элементов
        <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, int32(count))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запись элементов
        <span class="cov8" title="1">current = d.Head
        for current != nil </span><span class="cov8" title="1">{
                err = binary.Write(file, binary.LittleEndian, int32(current.Key))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        <span class="cov8" title="1">fmt.Printf("Двусвязный список сохранён в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла
func (d *DoublyLinkedList) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        d.Clear()

        var count int32
        err = binary.Read(file, binary.LittleEndian, &amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(count); i++ </span><span class="cov8" title="1">{
                var value int32
                err = binary.Read(file, binary.LittleEndian, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.AddToTail(int(value))</span>
        }

        <span class="cov8" title="1">fmt.Printf("Двусвязный список загружен из бинарного файла: %s\n", filename)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "os"
        "strconv"
        "strings"
)

// DynamicArray - динамический массив строк
type DynamicArray struct {
        data     []string
        size     int
        capacity int
}

// NewDynamicArray - конструктор
func NewDynamicArray(initialCapacity int) *DynamicArray <span class="cov8" title="1">{
        if initialCapacity &lt; 1 </span><span class="cov8" title="1">{
                initialCapacity = 10
        }</span>
        <span class="cov8" title="1">return &amp;DynamicArray{
                data:     make([]string, initialCapacity),
                size:     0,
                capacity: initialCapacity,
        }</span>
}

// resize - изменение размера массива
func (d *DynamicArray) resize(newCapacity int) <span class="cov8" title="1">{
        newData := make([]string, newCapacity)
        for i := 0; i &lt; d.size; i++ </span><span class="cov8" title="1">{
                newData[i] = d.data[i]
        }</span>
        <span class="cov8" title="1">d.data = newData
        d.capacity = newCapacity</span>
}

// PushBack - добавление в конец
func (d *DynamicArray) PushBack(value string) <span class="cov8" title="1">{
        if d.size &gt;= d.capacity </span><span class="cov8" title="1">{
                newCap := d.capacity * 2
                if newCap == 0 </span><span class="cov0" title="0">{
                        newCap = 4
                }</span>
                <span class="cov8" title="1">d.resize(newCap)</span>
        }
        <span class="cov8" title="1">d.data[d.size] = value
        d.size++</span>
}

// Insert - вставка по индексу
func (d *DynamicArray) Insert(index int, value string) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; d.size </span><span class="cov8" title="1">{
                fmt.Println("Неверный индекс!")
                return
        }</span>

        <span class="cov8" title="1">if d.size &gt;= d.capacity </span><span class="cov8" title="1">{
                d.resize(d.capacity * 2)
        }</span>

        <span class="cov8" title="1">for i := d.size; i &gt; index; i-- </span><span class="cov8" title="1">{
                d.data[i] = d.data[i-1]
        }</span>

        <span class="cov8" title="1">d.data[index] = value
        d.size++</span>
}

// Remove - удаление по индексу
func (d *DynamicArray) Remove(index int) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= d.size </span><span class="cov8" title="1">{
                fmt.Println("Неверный индекс")
                return
        }</span>

        <span class="cov8" title="1">for i := index; i &lt; d.size-1; i++ </span><span class="cov8" title="1">{
                d.data[i] = d.data[i+1]
        }</span>
        <span class="cov8" title="1">d.size--

        if d.size &lt; d.capacity/4 &amp;&amp; d.capacity &gt; 10 </span><span class="cov8" title="1">{
                d.resize(d.capacity / 2)
        }</span>
}

// Get - получение элемента по индексу
func (d *DynamicArray) Get(index int) string <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= d.size </span><span class="cov8" title="1">{
                fmt.Println("Неверный индекс")
                return ""
        }</span>
        <span class="cov8" title="1">return d.data[index]</span>
}

// Set - установка значения по индексу
func (d *DynamicArray) Set(index int, value string) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= d.size </span><span class="cov8" title="1">{
                fmt.Println("Неверный индекс")
                return
        }</span>
        <span class="cov8" title="1">d.data[index] = value</span>
}

// GetSize - получение размера
func (d *DynamicArray) GetSize() int <span class="cov8" title="1">{
        return d.size
}</span>

// GetCapacity - получение емкости
func (d *DynamicArray) GetCapacity() int <span class="cov8" title="1">{
        return d.capacity
}</span>

// Print - печать массива
func (d *DynamicArray) Print() <span class="cov8" title="1">{
        fmt.Printf("Массив[%d/%d]: ", d.size, d.capacity)
        for i := 0; i &lt; d.size; i++ </span><span class="cov8" title="1">{
                fmt.Printf("\"%s\" ", d.data[i])
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// Clear - очистка массива
func (d *DynamicArray) Clear() <span class="cov8" title="1">{
        d.size = 0
}</span>

// SaveToFile - сохранение в текстовый файл
func (d *DynamicArray) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка создания файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        _, err = fmt.Fprintf(file, "%d\n", d.size)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; d.size; i++ </span><span class="cov8" title="1">{
                _, err = fmt.Fprintf(file, "%s\n", d.data[i])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Массив сохранён в файл: %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (d *DynamicArray) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        d.Clear()

        scanner := bufio.NewScanner(file)

        // Читаем размер
        if !scanner.Scan() </span><span class="cov8" title="1">{
                return fmt.Errorf("файл пуст")
        }</span>
        <span class="cov8" title="1">n, err := strconv.Atoi(scanner.Text())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Читаем строки
        <span class="cov8" title="1">for i := 0; i &lt; n &amp;&amp; scanner.Scan(); i++ </span><span class="cov8" title="1">{
                value := scanner.Text()
                value = strings.TrimRight(value, "\n\r")
                d.PushBack(value)
        }</span>

        <span class="cov8" title="1">fmt.Printf("Массив загружен из файла: %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл
func (d *DynamicArray) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка создания бинарного файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Запись размера
        err = binary.Write(file, binary.LittleEndian, int32(d.size))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запись строк
        <span class="cov8" title="1">for i := 0; i &lt; d.size; i++ </span><span class="cov8" title="1">{
                str := d.data[i]
                strLen := int32(len(str))

                // Запись длины строки
                err = binary.Write(file, binary.LittleEndian, strLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Запись строки
                <span class="cov8" title="1">_, err = file.Write([]byte(str))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Динамический массив сохранён в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла
func (d *DynamicArray) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        d.Clear()

        var fileSize int32
        err = binary.Read(file, binary.LittleEndian, &amp;fileSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(fileSize); i++ </span><span class="cov8" title="1">{
                var strLen int32
                err = binary.Read(file, binary.LittleEndian, &amp;strLen)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">buffer := make([]byte, strLen)
                _, err = file.Read(buffer)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">d.PushBack(string(buffer))</span>
        }

        <span class="cov8" title="1">fmt.Printf("Динамический массив загружен из бинарного файла: %s\n", filename)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "math"
        "os"
        "strconv"
)

// TreeNode - узел бинарного дерева
type TreeNode struct {
        Data  int
        Left  *TreeNode
        Right *TreeNode
}

// NewTreeNode - конструктор узла
func NewTreeNode(value int) *TreeNode <span class="cov8" title="1">{
        return &amp;TreeNode{
                Data:  value,
                Left:  nil,
                Right: nil,
        }
}</span>

// FullBinaryTree - полное бинарное дерево
type FullBinaryTree struct {
        Root *TreeNode
}

// NewFullBinaryTree - конструктор дерева
func NewFullBinaryTree() *FullBinaryTree <span class="cov8" title="1">{
        return &amp;FullBinaryTree{
                Root: nil,
        }
}</span>

// clearRecursive - рекурсивная очистка
func (f *FullBinaryTree) clearRecursive(current *TreeNode) <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f.clearRecursive(current.Left)
        f.clearRecursive(current.Right)
        current.Left = nil
        current.Right = nil</span>
}

// searchRecursive - рекурсивный поиск
func (f *FullBinaryTree) searchRecursive(current *TreeNode, value int) bool <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if current.Data == value </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return f.searchRecursive(current.Left, value) || f.searchRecursive(current.Right, value)</span>
}

// countNodes - подсчет узлов
func (f *FullBinaryTree) countNodes(current *TreeNode) int <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return 1 + f.countNodes(current.Left) + f.countNodes(current.Right)</span>
}

// getHeight - получение высоты
func (f *FullBinaryTree) getHeight(current *TreeNode) int <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">leftHeight := f.getHeight(current.Left)
        rightHeight := f.getHeight(current.Right)
        if leftHeight &gt; rightHeight </span><span class="cov8" title="1">{
                return 1 + leftHeight
        }</span>
        <span class="cov8" title="1">return 1 + rightHeight</span>
}

// printInOrderRecursive - рекурсивный InOrder обход
func (f *FullBinaryTree) printInOrderRecursive(current *TreeNode) <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f.printInOrderRecursive(current.Left)
        fmt.Printf("%d ", current.Data)
        f.printInOrderRecursive(current.Right)</span>
}

// printPreOrderRecursive - рекурсивный PreOrder обход
func (f *FullBinaryTree) printPreOrderRecursive(current *TreeNode) <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">fmt.Printf("%d ", current.Data)
        f.printPreOrderRecursive(current.Left)
        f.printPreOrderRecursive(current.Right)</span>
}

// printPostOrderRecursive - рекурсивный PostOrder обход
func (f *FullBinaryTree) printPostOrderRecursive(current *TreeNode) <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f.printPostOrderRecursive(current.Left)
        f.printPostOrderRecursive(current.Right)
        fmt.Printf("%d ", current.Data)</span>
}

// Add - добавление элемента
func (f *FullBinaryTree) Add(value int) <span class="cov8" title="1">{
        if f.Root == nil </span><span class="cov8" title="1">{
                f.Root = NewTreeNode(value)
                fmt.Printf("Добавлен корень: %d\n", value)
                return
        }</span>

        <span class="cov8" title="1">queue := []*TreeNode{f.Root}

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]

                if current.Left == nil </span><span class="cov8" title="1">{
                        current.Left = NewTreeNode(value)
                        fmt.Printf("Добавлен элемент: %d\n", value)
                        return
                }</span> else<span class="cov8" title="1"> {
                        queue = append(queue, current.Left)
                }</span>

                <span class="cov8" title="1">if current.Right == nil </span><span class="cov8" title="1">{
                        current.Right = NewTreeNode(value)
                        fmt.Printf("Добавлен элемент: %d\n", value)
                        return
                }</span> else<span class="cov8" title="1"> {
                        queue = append(queue, current.Right)
                }</span>
        }
}

// Search - поиск элемента
func (f *FullBinaryTree) Search(value int) bool <span class="cov8" title="1">{
        found := f.searchRecursive(f.Root, value)
        if found </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d найден!\n", value)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Элемент %d не найден!\n", value)
        }</span>
        <span class="cov8" title="1">return found</span>
}

// IsFull - проверка на полное бинарное дерево
func (f *FullBinaryTree) IsFull() bool <span class="cov8" title="1">{
        if f.Root == nil </span><span class="cov8" title="1">{
                fmt.Println("Дерево пусто!")
                return true
        }</span>

        <span class="cov8" title="1">nodeCount := f.countNodes(f.Root)
        height := f.getHeight(f.Root)
        expectedNodes := int(math.Pow(2, float64(height))) - 1

        if nodeCount == expectedNodes </span><span class="cov8" title="1">{
                fmt.Println("Дерево является полным бинарным деревом!")
                return true
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Дерево НЕ является полным бинарным деревом.\n")
                fmt.Printf("Узлов: %d, Ожидается: %d\n", nodeCount, expectedNodes)
                return false
        }</span>
}

// PrintInOrder - InOrder обход
func (f *FullBinaryTree) PrintInOrder() <span class="cov8" title="1">{
        if f.Root == nil </span><span class="cov0" title="0">{
                fmt.Println("Дерево пусто!")
                return
        }</span>
        <span class="cov8" title="1">fmt.Print("In-Order обход: ")
        f.printInOrderRecursive(f.Root)
        fmt.Println()</span>
}

// PrintPreOrder - PreOrder обход
func (f *FullBinaryTree) PrintPreOrder() <span class="cov8" title="1">{
        if f.Root == nil </span><span class="cov0" title="0">{
                fmt.Println("Дерево пусто!")
                return
        }</span>
        <span class="cov8" title="1">fmt.Print("Pre-Order обход: ")
        f.printPreOrderRecursive(f.Root)
        fmt.Println()</span>
}

// PrintPostOrder - PostOrder обход
func (f *FullBinaryTree) PrintPostOrder() <span class="cov8" title="1">{
        if f.Root == nil </span><span class="cov0" title="0">{
                fmt.Println("Дерево пусто!")
                return
        }</span>
        <span class="cov8" title="1">fmt.Print("Post-Order обход: ")
        f.printPostOrderRecursive(f.Root)
        fmt.Println()</span>
}

// PrintLevelOrder - LevelOrder обход
func (f *FullBinaryTree) PrintLevelOrder() <span class="cov8" title="1">{
        if f.Root == nil </span><span class="cov0" title="0">{
                fmt.Println("Дерево пусто!")
                return
        }</span>

        <span class="cov8" title="1">fmt.Print("Level-Order обход: ")
        queue := []*TreeNode{f.Root}

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]
                fmt.Printf("%d ", current.Data)

                if current.Left != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Left)
                }</span>
                <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Right)
                }</span>
        }
        <span class="cov8" title="1">fmt.Println()</span>
}

// GetNodeCount - получение количества узлов
func (f *FullBinaryTree) GetNodeCount() int <span class="cov8" title="1">{
        return f.countNodes(f.Root)
}</span>

// GetTreeHeight - получение высоты дерева
func (f *FullBinaryTree) GetTreeHeight() int <span class="cov8" title="1">{
        return f.getHeight(f.Root)
}</span>

// Clear - очистка дерева
func (f *FullBinaryTree) Clear() <span class="cov8" title="1">{
        f.clearRecursive(f.Root)
        f.Root = nil
        fmt.Println("Дерево очищено!")
}</span>

// SaveToFile - сохранение в текстовый файл
func (f *FullBinaryTree) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if f.Root == nil </span><span class="cov8" title="1">{
                fmt.Println("Дерево пусто, файл пуст.")
                return nil
        }</span>

        <span class="cov8" title="1">queue := []*TreeNode{f.Root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]

                _, err := fmt.Fprintf(file, "%d ", current.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if current.Left != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Left)
                }</span>
                <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                        queue = append(queue, current.Right)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Дерево сохранено в файл: %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (f *FullBinaryTree) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        f.Clear()

        scanner := bufio.NewScanner(file)
        scanner.Split(bufio.ScanWords)

        for scanner.Scan() </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(scanner.Text())
                if err == nil </span><span class="cov8" title="1">{
                        f.Add(value)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Дерево загружено из файла: %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл
func (f *FullBinaryTree) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия бинарного файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if f.Root == nil </span><span class="cov8" title="1">{
                empty := int32(0)
                err := binary.Write(file, binary.LittleEndian, empty)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fmt.Printf("Пустое дерево сохранено в бинарный файл: %s\n", filename)
                return nil</span>
        }

        <span class="cov8" title="1">nodeCount := int32(f.GetNodeCount())
        err = binary.Write(file, binary.LittleEndian, nodeCount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">queue := []*TreeNode{f.Root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]

                // Запись значения узла
                err = binary.Write(file, binary.LittleEndian, int32(current.Data))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Флаги наличия потомков
                <span class="cov8" title="1">hasLeft := current.Left != nil
                hasRight := current.Right != nil

                err = binary.Write(file, binary.LittleEndian, hasLeft)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, hasRight)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if hasLeft </span><span class="cov8" title="1">{
                        queue = append(queue, current.Left)
                }</span>
                <span class="cov8" title="1">if hasRight </span><span class="cov8" title="1">{
                        queue = append(queue, current.Right)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Дерево сохранено в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла
func (f *FullBinaryTree) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия бинарного файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        f.Clear()

        var nodeCount int32
        err = binary.Read(file, binary.LittleEndian, &amp;nodeCount)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if nodeCount == 0 </span><span class="cov8" title="1">{
                fmt.Printf("Пустое дерево загружено из бинарного файла: %s\n", filename)
                return nil
        }</span>

        // Чтение корня
        <span class="cov8" title="1">var rootValue int32
        var hasLeft, hasRight bool

        err = binary.Read(file, binary.LittleEndian, &amp;rootValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = binary.Read(file, binary.LittleEndian, &amp;hasLeft)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = binary.Read(file, binary.LittleEndian, &amp;hasRight)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">f.Root = NewTreeNode(int(rootValue))
        queue := []*TreeNode{f.Root}
        nodeCount--

        for len(queue) &gt; 0 &amp;&amp; nodeCount &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]

                // Чтение левого потомка
                if hasLeft &amp;&amp; nodeCount &gt; 0 </span><span class="cov8" title="1">{
                        var leftValue int32
                        var leftHasLeft, leftHasRight bool

                        err = binary.Read(file, binary.LittleEndian, &amp;leftValue)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = binary.Read(file, binary.LittleEndian, &amp;leftHasLeft)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = binary.Read(file, binary.LittleEndian, &amp;leftHasRight)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">current.Left = NewTreeNode(int(leftValue))
                        queue = append(queue, current.Left)
                        nodeCount--</span>
                }

                // Чтение правого потомка
                <span class="cov8" title="1">if hasRight &amp;&amp; nodeCount &gt; 0 </span><span class="cov8" title="1">{
                        var rightValue int32
                        var rightHasLeft, rightHasRight bool

                        err = binary.Read(file, binary.LittleEndian, &amp;rightValue)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = binary.Read(file, binary.LittleEndian, &amp;rightHasLeft)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = binary.Read(file, binary.LittleEndian, &amp;rightHasRight)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">current.Right = NewTreeNode(int(rightValue))
                        queue = append(queue, current.Right)
                        nodeCount--</span>
                }

                // Чтение флагов для следующего узла
                <span class="cov8" title="1">if len(queue) &gt; 0 &amp;&amp; nodeCount &gt; 0 </span><span class="cov0" title="0">{
                        err = binary.Read(file, binary.LittleEndian, &amp;hasLeft)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = binary.Read(file, binary.LittleEndian, &amp;hasRight)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Printf("Дерево загружено из бинарного файла: %s\n", filename)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "os"
        "strconv"
        "strings"
)

// ==================== Хеш-функция ====================

// StringHash - экспортируемая хеш-функция
func StringHash(key string, mod int) int <span class="cov8" title="1">{
        if mod &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">hashVal := 0
        prime := 31

        for _, ch := range key </span><span class="cov8" title="1">{
                hashVal = (hashVal*prime + int(ch)) % mod
                if hashVal &lt; 0 </span><span class="cov0" title="0">{
                        hashVal = -hashVal
                }</span>
        }
        <span class="cov8" title="1">return hashVal</span>
}

// ==================== HashNode ====================

// HashNode - узел цепочечной хеш-таблицы
type HashNode struct {
        Key   string
        Value string
        Next  *HashNode
}

// NewHashNode - конструктор узла
func NewHashNode(key, value string) *HashNode <span class="cov8" title="1">{
        return &amp;HashNode{
                Key:   key,
                Value: value,
                Next:  nil,
        }
}</span>

// ==================== ChainHashTable ====================

// ChainHashTable - цепочечная хеш-таблица
type ChainHashTable struct {
        table    []*HashNode
        capacity int
}

// NewChainHashTable - конструктор
func NewChainHashTable(size int) *ChainHashTable <span class="cov8" title="1">{
        if size &lt; 1 </span><span class="cov8" title="1">{
                size = 1
        }</span>
        <span class="cov8" title="1">cht := &amp;ChainHashTable{
                table:    make([]*HashNode, size),
                capacity: size,
        }
        return cht</span>
}

// hashFunction - хеш-функция
func (c *ChainHashTable) hashFunction(key string) int <span class="cov8" title="1">{
        return StringHash(key, c.capacity)
}</span>

// Insert - вставка элемента
func (c *ChainHashTable) Insert(key, value string) <span class="cov8" title="1">{
        index := c.hashFunction(key)

        // Проверка на существование ключа
        current := c.table[index]
        for current != nil </span><span class="cov8" title="1">{
                if current.Key == key </span><span class="cov8" title="1">{
                        current.Value = value
                        fmt.Printf("Ключ '%s' обновлен\n", key)
                        return
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        // Вставка нового узла
        <span class="cov8" title="1">newNode := NewHashNode(key, value)
        newNode.Next = c.table[index]
        c.table[index] = newNode

        fmt.Printf("Добавлено: %s -&gt; %s (цепочка %d)\n", key, value, index)</span>
}

// Remove - удаление элемента
func (c *ChainHashTable) Remove(key string) bool <span class="cov8" title="1">{
        index := c.hashFunction(key)
        current := c.table[index]
        var previous *HashNode

        for current != nil </span><span class="cov8" title="1">{
                if current.Key == key </span><span class="cov8" title="1">{
                        if previous == nil </span><span class="cov8" title="1">{
                                c.table[index] = current.Next
                        }</span> else<span class="cov8" title="1"> {
                                previous.Next = current.Next
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("Ключ '%s' удален\n", key)
                        return true</span>
                }
                <span class="cov8" title="1">previous = current
                current = current.Next</span>
        }

        <span class="cov8" title="1">fmt.Printf("Ключ '%s' не найден\n", key)
        return false</span>
}

// Find - поиск элемента
func (c *ChainHashTable) Find(key string) string <span class="cov8" title="1">{
        index := c.hashFunction(key)
        current := c.table[index]

        for current != nil </span><span class="cov8" title="1">{
                if current.Key == key </span><span class="cov8" title="1">{
                        return current.Value
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// Display - отображение таблицы
func (c *ChainHashTable) Display() <span class="cov8" title="1">{
        fmt.Printf("\n=== ЦЕПОЧЕЧНАЯ ХЕШ-ТАБЛИЦА (%d ячеек) ===\n", c.capacity)

        isEmpty := true
        for i := 0; i &lt; c.capacity; i++ </span><span class="cov8" title="1">{
                if c.table[i] != nil </span><span class="cov8" title="1">{
                        isEmpty = false
                        fmt.Printf("[%d]: ", i)

                        current := c.table[i]
                        for current != nil </span><span class="cov8" title="1">{
                                fmt.Printf("%s=%s", current.Key, current.Value)
                                if current.Next != nil </span><span class="cov8" title="1">{
                                        fmt.Printf(" -&gt; ")
                                }</span>
                                <span class="cov8" title="1">current = current.Next</span>
                        }
                        <span class="cov8" title="1">fmt.Println()</span>
                }
        }

        <span class="cov8" title="1">if isEmpty </span><span class="cov8" title="1">{
                fmt.Println("Таблица пуста")
        }</span>
}

// Clear - очистка таблицы
func (c *ChainHashTable) Clear() <span class="cov8" title="1">{
        for i := 0; i &lt; c.capacity; i++ </span><span class="cov8" title="1">{
                c.table[i] = nil
        }</span>
        <span class="cov8" title="1">fmt.Println("Цепочечная таблица очищена")</span>
}

// Resize - изменение размера
func (c *ChainHashTable) Resize(newSize int) <span class="cov8" title="1">{
        if newSize &lt; 1 </span><span class="cov8" title="1">{
                fmt.Println("Некорректный размер")
                return
        }</span>

        <span class="cov8" title="1">oldTable := c.table
        oldCapacity := c.capacity

        c.capacity = newSize
        c.table = make([]*HashNode, newSize)

        // Перехеширование
        for i := 0; i &lt; oldCapacity; i++ </span><span class="cov8" title="1">{
                current := oldTable[i]
                for current != nil </span><span class="cov8" title="1">{
                        next := current.Next
                        newIndex := c.hashFunction(current.Key)
                        current.Next = c.table[newIndex]
                        c.table[newIndex] = current
                        current = next
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Таблица изменена до %d ячеек\n", c.capacity)</span>
}

// GetSize - получение количества элементов
func (c *ChainHashTable) GetSize() int <span class="cov8" title="1">{
        count := 0
        for i := 0; i &lt; c.capacity; i++ </span><span class="cov8" title="1">{
                current := c.table[i]
                for current != nil </span><span class="cov8" title="1">{
                        count++
                        current = current.Next
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// GetCapacity - получение емкости
func (c *ChainHashTable) GetCapacity() int <span class="cov8" title="1">{
        return c.capacity
}</span>

// SaveToFile - сохранение в текстовый файл
func (c *ChainHashTable) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        _, err = fmt.Fprintf(file, "CHAIN_HASH_TABLE\n")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = fmt.Fprintf(file, "%d\n", c.capacity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; c.capacity; i++ </span><span class="cov8" title="1">{
                current := c.table[i]
                for current != nil </span><span class="cov8" title="1">{
                        _, err = fmt.Fprintf(file, "%s %s\n", current.Key, current.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">current = current.Next</span>
                }
        }

        <span class="cov8" title="1">fmt.Printf("Цепочечная таблица сохранена в %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (c *ChainHashTable) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)

        if !scanner.Scan() </span><span class="cov0" title="0">{
                return fmt.Errorf("файл пуст")
        }</span>
        <span class="cov8" title="1">typeStr := scanner.Text()
        if typeStr != "CHAIN_HASH_TABLE" </span><span class="cov0" title="0">{
                fmt.Println("Неверный формат файла")
                return fmt.Errorf("неверный формат файла")
        }</span>

        <span class="cov8" title="1">if !scanner.Scan() </span><span class="cov0" title="0">{
                return fmt.Errorf("файл поврежден")
        }</span>
        <span class="cov8" title="1">fileCapacity, err := strconv.Atoi(scanner.Text())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.Clear()
        if fileCapacity != c.capacity </span><span class="cov8" title="1">{
                c.table = make([]*HashNode, fileCapacity)
                c.capacity = fileCapacity
        }</span>

        <span class="cov8" title="1">for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                parts := strings.SplitN(line, " ", 2)
                if len(parts) == 2 </span><span class="cov8" title="1">{
                        c.Insert(parts[0], parts[1])
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Цепочечная таблица загружена из %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл (ChainHashTable)
func (c *ChainHashTable) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Сигнатура - ровно 16 байт
        signature := []byte("CHAIN_HASH_BIN_16")
        _, err = file.Write(signature)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запись capacity
        <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, int32(c.capacity))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запись количества элементов
        <span class="cov8" title="1">numElements := int32(c.GetSize())
        err = binary.Write(file, binary.LittleEndian, numElements)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запись элементов
        <span class="cov8" title="1">for i := 0; i &lt; c.capacity; i++ </span><span class="cov8" title="1">{
                current := c.table[i]
                for current != nil </span><span class="cov8" title="1">{
                        keyLen := int32(len(current.Key))
                        valueLen := int32(len(current.Value))

                        err = binary.Write(file, binary.LittleEndian, keyLen)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">_, err = file.Write([]byte(current.Key))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, valueLen)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">_, err = file.Write([]byte(current.Value))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">current = current.Next</span>
                }
        }

        <span class="cov8" title="1">fmt.Printf("Цепочечная таблица сохранена в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла (ChainHashTable)
func (c *ChainHashTable) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Чтение сигнатуры
        signature := make([]byte, 16)
        _, err = file.Read(signature)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if string(signature) != "CHAIN_HASH_BIN_16" </span><span class="cov8" title="1">{
                fmt.Println("Неверный формат файла")
                return fmt.Errorf("неверный формат файла")
        }</span>

        <span class="cov0" title="0">var fileCapacity int32
        err = binary.Read(file, binary.LittleEndian, &amp;fileCapacity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.Clear()
        c.capacity = int(fileCapacity)
        c.table = make([]*HashNode, c.capacity)

        var numElements int32
        err = binary.Read(file, binary.LittleEndian, &amp;numElements)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; int(numElements); i++ </span><span class="cov0" title="0">{
                var keyLen int32
                err = binary.Read(file, binary.LittleEndian, &amp;keyLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">keyBuf := make([]byte, keyLen)
                _, err = file.Read(keyBuf)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">key := string(keyBuf)

                var valueLen int32
                err = binary.Read(file, binary.LittleEndian, &amp;valueLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">valueBuf := make([]byte, valueLen)
                _, err = file.Read(valueBuf)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">value := string(valueBuf)

                c.Insert(key, value)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Цепочечная таблица загружена из %s\n", filename)
        return nil</span>
}

// ==================== OpenHashEntry ====================

// OpenHashEntry - запись в открытой хеш-таблице
type OpenHashEntry struct {
        Key     string
        Value   string
        Used    bool
        Deleted bool
}

// NewOpenHashEntry - конструктор
func NewOpenHashEntry() OpenHashEntry <span class="cov8" title="1">{
        return OpenHashEntry{
                Used:    false,
                Deleted: false,
        }
}</span>

// ==================== OpenHashTable ====================

// OpenHashTable - хеш-таблица с открытой адресацией
type OpenHashTable struct {
        table    []OpenHashEntry
        capacity int
}

// NewOpenHashTable - конструктор
func NewOpenHashTable(size int) *OpenHashTable <span class="cov8" title="1">{
        if size &lt; 1 </span><span class="cov8" title="1">{
                size = 1
        }</span>
        <span class="cov8" title="1">oht := &amp;OpenHashTable{
                table:    make([]OpenHashEntry, size),
                capacity: size,
        }
        for i := 0; i &lt; size; i++ </span><span class="cov8" title="1">{
                oht.table[i] = NewOpenHashEntry()
        }</span>
        <span class="cov8" title="1">return oht</span>
}

// hashFunction - хеш-функция
func (o *OpenHashTable) hashFunction(key string) int <span class="cov8" title="1">{
        return StringHash(key, o.capacity)
}</span>

// probeFunction - функция пробирования
func (o *OpenHashTable) probeFunction(index, attempt int) int <span class="cov8" title="1">{
        return (index + attempt) % o.capacity
}</span>

// Insert - вставка элемента
func (o *OpenHashTable) Insert(key, value string) <span class="cov8" title="1">{
        index := o.hashFunction(key)

        for attempt := 0; attempt &lt; o.capacity; attempt++ </span><span class="cov8" title="1">{
                currentIndex := o.probeFunction(index, attempt)

                if !o.table[currentIndex].Used || o.table[currentIndex].Deleted </span><span class="cov8" title="1">{
                        o.table[currentIndex].Key = key
                        o.table[currentIndex].Value = value
                        o.table[currentIndex].Used = true
                        o.table[currentIndex].Deleted = false
                        fmt.Printf("Добавлено: %s -&gt; %s (ячейка %d)\n", key, value, currentIndex)
                        return
                }</span>

                <span class="cov8" title="1">if o.table[currentIndex].Used &amp;&amp; o.table[currentIndex].Key == key </span><span class="cov8" title="1">{
                        o.table[currentIndex].Value = value
                        fmt.Printf("Ключ '%s' обновлен\n", key)
                        return
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Таблица переполнена, невозможно добавить '%s'\n", key)</span>
}

// Remove - удаление элемента
func (o *OpenHashTable) Remove(key string) bool <span class="cov8" title="1">{
        index := o.hashFunction(key)

        for attempt := 0; attempt &lt; o.capacity; attempt++ </span><span class="cov8" title="1">{
                currentIndex := o.probeFunction(index, attempt)

                if o.table[currentIndex].Used &amp;&amp; o.table[currentIndex].Key == key </span><span class="cov8" title="1">{
                        o.table[currentIndex].Used = false
                        o.table[currentIndex].Deleted = true
                        fmt.Printf("Ключ '%s' удален\n", key)
                        return true
                }</span>

                <span class="cov8" title="1">if !o.table[currentIndex].Used &amp;&amp; !o.table[currentIndex].Deleted </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">fmt.Printf("Ключ '%s' не найден\n", key)
        return false</span>
}

// Find - поиск элемента
func (o *OpenHashTable) Find(key string) string <span class="cov8" title="1">{
        index := o.hashFunction(key)

        for attempt := 0; attempt &lt; o.capacity; attempt++ </span><span class="cov8" title="1">{
                currentIndex := o.probeFunction(index, attempt)

                if o.table[currentIndex].Used &amp;&amp; o.table[currentIndex].Key == key </span><span class="cov8" title="1">{
                        return o.table[currentIndex].Value
                }</span>

                <span class="cov8" title="1">if !o.table[currentIndex].Used &amp;&amp; !o.table[currentIndex].Deleted </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// Display - отображение таблицы
func (o *OpenHashTable) Display() <span class="cov8" title="1">{
        fmt.Printf("\n=== ХЕШ-ТАБЛИЦА С ОТКРЫТОЙ АДРЕСАЦИЕЙ (%d ячеек) ===\n", o.capacity)

        isEmpty := true
        for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                if o.table[i].Used </span><span class="cov8" title="1">{
                        isEmpty = false
                        fmt.Printf("[%d]: %s=%s", i, o.table[i].Key, o.table[i].Value)
                        if o.table[i].Deleted </span><span class="cov0" title="0">{
                                fmt.Printf(" [УДАЛЕНО]")
                        }</span>
                        <span class="cov8" title="1">fmt.Println()</span>
                } else<span class="cov8" title="1"> if o.table[i].Deleted </span><span class="cov8" title="1">{
                        isEmpty = false
                        fmt.Printf("[%d]: [УДАЛЕНО]\n", i)
                }</span>
        }

        <span class="cov8" title="1">if isEmpty </span><span class="cov8" title="1">{
                fmt.Println("Таблица пуста")
        }</span>
}

// Clear - очистка таблицы
func (o *OpenHashTable) Clear() <span class="cov8" title="1">{
        for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                o.table[i].Used = false
                o.table[i].Deleted = false
                o.table[i].Key = ""
                o.table[i].Value = ""
        }</span>
        <span class="cov8" title="1">fmt.Println("Таблица с открытой адресацией очищена")</span>
}

// Resize - изменение размера
func (o *OpenHashTable) Resize(newSize int) <span class="cov8" title="1">{
        if newSize &lt; 1 </span><span class="cov8" title="1">{
                fmt.Println("Некорректный размер")
                return
        }</span>

        <span class="cov8" title="1">oldTable := o.table
        oldCapacity := o.capacity

        o.capacity = newSize
        o.table = make([]OpenHashEntry, newSize)
        for i := 0; i &lt; newSize; i++ </span><span class="cov8" title="1">{
                o.table[i] = NewOpenHashEntry()
        }</span>

        // Перехеширование
        <span class="cov8" title="1">for i := 0; i &lt; oldCapacity; i++ </span><span class="cov8" title="1">{
                if oldTable[i].Used &amp;&amp; !oldTable[i].Deleted </span><span class="cov8" title="1">{
                        key := oldTable[i].Key
                        value := oldTable[i].Value
                        index := o.hashFunction(key)

                        for attempt := 0; attempt &lt; o.capacity; attempt++ </span><span class="cov8" title="1">{
                                currentIndex := o.probeFunction(index, attempt)
                                if !o.table[currentIndex].Used || o.table[currentIndex].Deleted </span><span class="cov8" title="1">{
                                        o.table[currentIndex].Key = key
                                        o.table[currentIndex].Value = value
                                        o.table[currentIndex].Used = true
                                        o.table[currentIndex].Deleted = false
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">fmt.Printf("Таблица изменена до %d ячеек\n", o.capacity)</span>
}

// GetSize - получение количества элементов
func (o *OpenHashTable) GetSize() int <span class="cov8" title="1">{
        count := 0
        for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                if o.table[i].Used </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// GetCapacity - получение емкости
func (o *OpenHashTable) GetCapacity() int <span class="cov8" title="1">{
        return o.capacity
}</span>

// GetLoadFactor - получение коэффициента заполнения
func (o *OpenHashTable) GetLoadFactor() float64 <span class="cov8" title="1">{
        size := o.GetSize()
        if size == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(size) / float64(o.capacity)</span>
}

// SaveToFile - сохранение в текстовый файл
func (o *OpenHashTable) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        _, err = fmt.Fprintf(file, "OPEN_HASH_TABLE\n")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = fmt.Fprintf(file, "%d\n", o.capacity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                if o.table[i].Used </span><span class="cov8" title="1">{
                        _, err = fmt.Fprintf(file, "%s %s\n", o.table[i].Key, o.table[i].Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Printf("Таблица с открытой адресацией сохранена в %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (o *OpenHashTable) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)

        if !scanner.Scan() </span><span class="cov0" title="0">{
                return fmt.Errorf("файл пуст")
        }</span>
        <span class="cov8" title="1">typeStr := scanner.Text()
        if typeStr != "OPEN_HASH_TABLE" </span><span class="cov0" title="0">{
                fmt.Println("Неверный формат файла")
                return fmt.Errorf("неверный формат файла")
        }</span>

        <span class="cov8" title="1">if !scanner.Scan() </span><span class="cov0" title="0">{
                return fmt.Errorf("файл поврежден")
        }</span>
        <span class="cov8" title="1">fileCapacity, err := strconv.Atoi(scanner.Text())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">o.Clear()
        if fileCapacity != o.capacity </span><span class="cov8" title="1">{
                o.table = make([]OpenHashEntry, fileCapacity)
                o.capacity = fileCapacity
                for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                        o.table[i] = NewOpenHashEntry()
                }</span>
        }

        <span class="cov8" title="1">for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                parts := strings.SplitN(line, " ", 2)
                if len(parts) == 2 </span><span class="cov8" title="1">{
                        o.Insert(parts[0], parts[1])
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Таблица с открытой адресацией загружена из %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл (OpenHashTable)
func (o *OpenHashTable) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Сигнатура - ровно 16 байт
        signature := []byte("OPEN_HASH_BIN_16")
        _, err = file.Write(signature)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запись capacity
        <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, int32(o.capacity))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Количество активных элементов
        <span class="cov8" title="1">numElements := int32(0)
        for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                if o.table[i].Used &amp;&amp; !o.table[i].Deleted </span><span class="cov8" title="1">{
                        numElements++
                }</span>
        }
        <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, numElements)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Запись элементов
        <span class="cov8" title="1">for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                if o.table[i].Used &amp;&amp; !o.table[i].Deleted </span><span class="cov8" title="1">{
                        keyLen := int32(len(o.table[i].Key))
                        valueLen := int32(len(o.table[i].Value))

                        err = binary.Write(file, binary.LittleEndian, keyLen)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">_, err = file.Write([]byte(o.table[i].Key))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, valueLen)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">_, err = file.Write([]byte(o.table[i].Value))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Printf("Таблица с открытой адресацией сохранена в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла (OpenHashTable)
func (o *OpenHashTable) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Чтение сигнатуры
        signature := make([]byte, 16)
        _, err = file.Read(signature)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if string(signature) != "OPEN_HASH_BIN_16" </span><span class="cov8" title="1">{
                fmt.Println("Неверный формат файла")
                return fmt.Errorf("неверный формат файла")
        }</span>

        <span class="cov8" title="1">var fileCapacity int32
        err = binary.Read(file, binary.LittleEndian, &amp;fileCapacity)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">o.Clear()
        o.capacity = int(fileCapacity)
        o.table = make([]OpenHashEntry, o.capacity)
        for i := 0; i &lt; o.capacity; i++ </span><span class="cov8" title="1">{
                o.table[i] = NewOpenHashEntry()
        }</span>

        <span class="cov8" title="1">var numElements int32
        err = binary.Read(file, binary.LittleEndian, &amp;numElements)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(numElements); i++ </span><span class="cov8" title="1">{
                var keyLen int32
                err = binary.Read(file, binary.LittleEndian, &amp;keyLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">keyBuf := make([]byte, keyLen)
                _, err = file.Read(keyBuf)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">key := string(keyBuf)

                var valueLen int32
                err = binary.Read(file, binary.LittleEndian, &amp;valueLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">valueBuf := make([]byte, valueLen)
                _, err = file.Read(valueBuf)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">value := string(valueBuf)

                inserted := false
                for attempt := 0; attempt &lt; o.capacity; attempt++ </span><span class="cov8" title="1">{
                        index := o.probeFunction(o.hashFunction(key), attempt)
                        if !o.table[index].Used || o.table[index].Deleted </span><span class="cov8" title="1">{
                                o.table[index].Key = key
                                o.table[index].Value = value
                                o.table[index].Used = true
                                o.table[index].Deleted = false
                                inserted = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !inserted </span><span class="cov0" title="0">{
                        fmt.Printf("Предупреждение: не удалось вставить элемент %s при загрузке\n", key)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Таблица с открытой адресацией загружена из бинарного файла: %s\n", filename)
        return nil</span>
}

// ==================== Вспомогательные функции ====================

// ParseCommand - парсинг команд
func ParseCommand(line string) (cmd, arg1, arg2 string) <span class="cov8" title="1">{
        parts := strings.SplitN(line, " ", 3)
        if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                cmd = parts[0]
        }</span>
        <span class="cov8" title="1">if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                arg1 = parts[1]
        }</span>
        <span class="cov8" title="1">if len(parts) &gt; 2 </span><span class="cov8" title="1">{
                arg2 = parts[2]
        }</span>
        <span class="cov8" title="1">return</span>
}

// DisplayMenu - отображение меню
func DisplayMenu() <span class="cov8" title="1">{
        fmt.Println("\n=== МЕНЮ ХЕШ-ТАБЛИЦ ===")
        fmt.Println("1. Добавить элемент")
        fmt.Println("2. Найти элемент")
        fmt.Println("3. Удалить элемент")
        fmt.Println("4. Показать таблицы")
        fmt.Println("5. Очистить таблицы")
        fmt.Println("6. Изменить размер таблиц")
        fmt.Println("7. Сохранить в файл")
        fmt.Println("8. Загрузить из файла")
        fmt.Println("9. Статистика")
        fmt.Println("0. Выход")
        fmt.Print("Выберите действие: ")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

// Функции демонстрации

func demonstrateFullBinaryTree() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ ПОЛНОГО БИНАРНОГО ДЕРЕВА ---")

        tree := NewFullBinaryTree()

        // Добавление элементов
        tree.Add(10)
        tree.Add(5)
        tree.Add(15)
        tree.Add(3)
        tree.Add(7)
        tree.Add(12)
        tree.Add(18)

        // Обходы
        tree.PrintInOrder()
        tree.PrintPreOrder()
        tree.PrintPostOrder()
        tree.PrintLevelOrder()

        // Поиск
        tree.Search(7)
        tree.Search(100)

        // Проверка полноты
        tree.IsFull()

        // Информация
        fmt.Printf("Количество узлов: %d\n", tree.GetNodeCount())
        fmt.Printf("Высота дерева: %d\n", tree.GetTreeHeight())

        // Сохранение/загрузка
        tree.SaveToFile("tree.txt")

        tree2 := NewFullBinaryTree()
        tree2.LoadFromFile("tree.txt")
        tree2.PrintLevelOrder()
}</span>

func demonstrateSinglyLinkedList() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ ОДНОСВЯЗНОГО СПИСКА ---")

        list := NewSinglyLinkedList()

        // Добавление элементов
        list.AddToHead(30)
        list.AddToHead(20)
        list.AddToHead(10)
        list.AddToTail(40)
        list.AddToTail(50)

        // Печать
        list.Print()
        list.PrintReverse()

        // Добавление между элементами
        list.AddAfter(30, 35)
        list.AddBefore(40, 38)
        list.Print()

        // Удаление
        list.DeleteFromHead()
        list.DeleteFromTail()
        list.DeleteByValue(35)
        list.Print()

        // Поиск
        fmt.Printf("Поиск 38: %v\n", list.FindByValue(38))
        fmt.Printf("Поиск 100: %v\n", list.FindByValue(100))

        // Сохранение/загрузка
        list.SaveToFile("singly_list.txt")

        list2 := NewSinglyLinkedList()
        list2.LoadFromFile("singly_list.txt")
        list2.Print()
}</span>

func demonstrateDoublyLinkedList() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ ДВУСВЯЗНОГО СПИСКА ---")

        dlist := NewDoublyLinkedList()

        // Добавление элементов
        dlist.AddToHead(30)
        dlist.AddToHead(20)
        dlist.AddToHead(10)
        dlist.AddToTail(40)
        dlist.AddToTail(50)

        // Печать в обе стороны
        dlist.PrintForward()
        dlist.PrintBackward()

        // Добавление между элементами
        dlist.AddAfterValue(30, 35)
        dlist.AddBeforeValue(40, 38)
        dlist.PrintForward()

        // Удаление
        dlist.DeleteFromHead()
        dlist.DeleteFromTail()
        dlist.DeleteByValue(35)
        dlist.PrintForward()

        // Поиск
        fmt.Printf("Поиск 38: %v\n", dlist.FindByValue(38))

        // Сохранение/загрузка
        dlist.SaveToFile("doubly_list.txt")

        dlist2 := NewDoublyLinkedList()
        dlist2.LoadFromFile("doubly_list.txt")
        dlist2.PrintForward()
}</span>

func demonstrateDynamicArray() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ ДИНАМИЧЕСКОГО МАССИВА ---")

        arr := NewDynamicArray(5)

        // Добавление элементов
        arr.PushBack("Hello")
        arr.PushBack("World")
        arr.PushBack("C++")
        arr.PushBack("Programming")
        arr.PushBack("Data Structures")

        // Печать
        arr.Print()

        // Вставка
        arr.Insert(2, "Awesome")
        arr.Print()

        // Изменение
        arr.Set(3, "Changed")
        arr.Print()

        // Удаление
        arr.Remove(1)
        arr.Print()

        // Получение элемента
        fmt.Printf("Элемент с индексом 2: %s\n", arr.Get(2))

        // Информация
        fmt.Printf("Размер: %d\n", arr.GetSize())
        fmt.Printf("Емкость: %d\n", arr.GetCapacity())

        // Сохранение/загрузка
        arr.SaveToFile("array.txt")

        arr2 := NewDynamicArray(5)
        arr2.LoadFromFile("array.txt")
        arr2.Print()
}</span>

func demonstrateQueue() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ ОЧЕРЕДИ ---")

        queue := NewQueue()

        // Добавление элементов
        queue.Push(10)
        queue.Push(20)
        queue.Push(30)
        queue.Push(40)
        queue.Push(50)

        // Отображение
        queue.Display()

        // Удаление
        queue.Pop()
        queue.Pop()
        queue.Display()

        // Получение первого элемента
        fmt.Printf("Первый элемент: %d\n", queue.Front())

        // Информация
        fmt.Printf("Размер очереди: %d\n", queue.Size())
        fmt.Printf("Очередь пуста: %v\n", queue.IsEmpty())

        // Сохранение/загрузка
        queue.SaveToFile("queue.txt")

        queue2 := NewQueue()
        queue2.LoadFromFile("queue.txt")
        queue2.Display()
}</span>

func demonstrateStack() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ СТЕКА ---")

        stack := NewStack()

        // Добавление элементов
        stack.Push(10)
        stack.Push(20)
        stack.Push(30)
        stack.Push(40)
        stack.Push(50)

        // Печать
        stack.Print()

        // Удаление
        stack.Pop()
        stack.Pop()
        stack.Print()

        // Получение верхнего элемента
        fmt.Printf("Верхний элемент: %d\n", stack.Peek())

        // Информация
        fmt.Printf("Размер стека: %d\n", stack.Size())
        fmt.Printf("Стек пуст: %v\n", stack.IsEmpty())

        // Сохранение/загрузка
        stack.SaveToFile("stack.txt")

        stack2 := NewStack()
        stack2.LoadFromFile("stack.txt")
        stack2.Print()
}</span>

func demonstrateHashTable() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ ХЕШ-ТАБЛИЦ ---")

        // Создаем две реализации хеш-таблиц
        chainTable := NewChainHashTable(5)
        openTable := NewOpenHashTable(5)

        fmt.Println("\n1. Добавление элементов:")
        chainTable.Insert("name", "Ivan")
        openTable.Insert("name", "Ivan")

        chainTable.Insert("age", "25")
        openTable.Insert("age", "25")

        chainTable.Insert("city", "Moscow")
        openTable.Insert("city", "Moscow")

        chainTable.Insert("job", "Developer")
        openTable.Insert("job", "Developer")

        chainTable.Insert("country", "Russia")
        openTable.Insert("country", "Russia")

        // Показываем таблицы
        fmt.Println("\n2. Содержимое таблиц:")
        chainTable.Display()
        openTable.Display()

        // Поиск элементов
        fmt.Println("\n3. Поиск элементов:")
        fmt.Printf("Поиск 'name': %s\n", chainTable.Find("name"))
        fmt.Printf("Поиск 'age': %s\n", openTable.Find("age"))
        fmt.Printf("Поиск несуществующего 'salary': %s\n", chainTable.Find("salary"))

        // Демонстрация коллизий
        fmt.Println("\n4. Демонстрация коллизий:")
        chainTable.Insert("abc", "value1")
        chainTable.Insert("cba", "value2")

        openTable.Insert("abc", "value1")
        openTable.Insert("cba", "value2")

        chainTable.Display()
        openTable.Display()

        // Удаление
        fmt.Println("\n5. Удаление элементов:")
        chainTable.Remove("city")
        openTable.Remove("city")

        fmt.Println("\n6. После удаления 'city':")
        chainTable.Display()
        openTable.Display()

        // Изменение размера
        fmt.Println("\n7. Изменение размера таблиц:")
        chainTable.Resize(10)
        openTable.Resize(10)

        fmt.Println("После изменения размера:")
        chainTable.Display()
        openTable.Display()

        // Статистика
        fmt.Println("\n8. Статистика:")
        fmt.Println("Цепочечная таблица:")
        fmt.Printf("  Емкость: %d\n", chainTable.GetCapacity())
        fmt.Printf("  Элементов: %d\n", chainTable.GetSize())

        fmt.Println("Таблица с открытой адресацией:")
        fmt.Printf("  Емкость: %d\n", openTable.GetCapacity())
        fmt.Printf("  Элементов: %d\n", openTable.GetSize())
        fmt.Printf("  Коэффициент заполнения: %.1f%%\n", openTable.GetLoadFactor()*100)

        // Сохранение и загрузка
        fmt.Println("\n9. Сохранение и загрузка:")
        chainTable.SaveToFile("chain_table.txt")
        openTable.SaveToFile("open_table.txt")

        chainTable2 := NewChainHashTable(5)
        openTable2 := NewOpenHashTable(5)

        chainTable2.LoadFromFile("chain_table.txt")
        openTable2.LoadFromFile("open_table.txt")

        fmt.Println("Загруженные таблицы:")
        chainTable2.Display()
        openTable2.Display()
}</span>

func demonstrateBinarySerialization() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ БИНАРНОЙ СЕРИАЛИЗАЦИИ ---")

        // Пример для двусвязного списка
        binaryList := NewDoublyLinkedList()
        binaryList.AddToHead(100)
        binaryList.AddToTail(200)
        binaryList.AddToTail(300)

        fmt.Println("\nИсходный список:")
        binaryList.PrintForward()

        // Сохраняем в бинарный файл
        binaryList.SaveToBinaryFile("binary_list.bin")

        // Загружаем из бинарного файла
        loadedList := NewDoublyLinkedList()
        loadedList.LoadFromBinaryFile("binary_list.bin")

        fmt.Println("\nЗагруженный список:")
        loadedList.PrintForward()

        // Пример для динамического массива
        fmt.Println("\n=== ДИНАМИЧЕСКИЙ МАССИВ ===")
        binaryArray := NewDynamicArray(5)
        binaryArray.PushBack("Hello")
        binaryArray.PushBack("World")
        binaryArray.PushBack("Binary")

        fmt.Println("\nИсходный массив:")
        binaryArray.Print()

        // Сохраняем в бинарный файл
        binaryArray.SaveToBinaryFile("binary_array.bin")

        // Загружаем из бинарного файла
        loadedArray := NewDynamicArray(5)
        loadedArray.LoadFromBinaryFile("binary_array.bin")

        fmt.Println("\nЗагруженный массив:")
        loadedArray.Print()

        // Пример для очереди
        fmt.Println("\n=== ОЧЕРЕДЬ ===")
        binaryQueue := NewQueue()
        binaryQueue.Push(555)
        binaryQueue.Push(666)
        binaryQueue.Push(777)

        fmt.Println("\nИсходная очередь:")
        binaryQueue.Display()

        // Сохраняем в бинарный файл
        binaryQueue.SaveToBinaryFile("binary_queue.bin")

        // Загружаем из бинарного файла
        loadedQueue := NewQueue()
        loadedQueue.LoadFromBinaryFile("binary_queue.bin")

        fmt.Println("\nЗагруженная очередь:")
        loadedQueue.Display()

        // Пример для стека
        fmt.Println("\n--- СТЕК ---")
        binaryStack := NewStack()
        binaryStack.Push(111)
        binaryStack.Push(222)
        binaryStack.Push(333)

        fmt.Println("\nИсходный стек:")
        binaryStack.Print()

        // Сохраняем в бинарный файл
        binaryStack.SaveToBinaryFile("binary_stack.bin")

        // Загружаем из бинарного файла
        loadedStack := NewStack()
        loadedStack.LoadFromBinaryFile("binary_stack.bin")

        fmt.Println("\nЗагруженный стек:")
        loadedStack.Print()

        fmt.Println("\nБинарная сериализация успешно продемонстрирована!")
        fmt.Println("Созданы файлы: binary_list.bin, binary_array.bin, binary_queue.bin, binary_stack.bin")
}</span>

func demonstrateAllSerialization() <span class="cov0" title="0">{
        fmt.Println("\n--- ДЕМОНСТРАЦИЯ ВСЕХ ВИДОВ СЕРИАЛИЗАЦИИ ---")

        // Тест для односвязного списка
        fmt.Println("\n1. ОДНОСВЯЗНЫЙ СПИСОК:")
        list := NewSinglyLinkedList()
        list.AddToHead(50)
        list.AddToTail(60)
        list.AddToTail(70)

        fmt.Print("Исходный список: ")
        list.Print()

        // Текстовая сериализация
        list.SaveToFile("test_singly.txt")
        // Бинарная сериализация
        list.SaveToBinaryFile("test_singly.bin")

        listFromText := NewSinglyLinkedList()
        listFromBinary := NewSinglyLinkedList()
        listFromText.LoadFromFile("test_singly.txt")
        listFromBinary.LoadFromBinaryFile("test_singly.bin")

        fmt.Print("Из текстового файла: ")
        listFromText.Print()
        fmt.Print("Из бинарного файла: ")
        listFromBinary.Print()

        // Тест для хеш-таблиц
        fmt.Println("\n2. ХЕШ-ТАБЛИЦЫ:")
        hashTable := NewChainHashTable(3)
        hashTable.Insert("test", "value1")
        hashTable.Insert("key", "value2")

        fmt.Println("Исходная таблица:")
        hashTable.Display()

        // Текстовая сериализация
        hashTable.SaveToFile("test_hash.txt")
        // Бинарная сериализация
        hashTable.SaveToBinaryFile("test_hash.bin")

        hashFromText := NewChainHashTable(3)
        hashFromBinary := NewChainHashTable(3)
        hashFromText.LoadFromFile("test_hash.txt")
        hashFromBinary.LoadFromBinaryFile("test_hash.bin")

        fmt.Println("Из текстового файла:")
        hashFromText.Display()
        fmt.Println("Из бинарного файла:")
        hashFromBinary.Display()

        fmt.Println("\nВсе виды сериализации успешно протестированы!")
}</span>

// Интерактивный режим для хеш-таблиц
func demonstrateHashTableInteractive() <span class="cov0" title="0">{
        fmt.Println("\n--- ИНТЕРАКТИВНАЯ РАБОТА С ХЕШ-ТАБЛИЦАМИ ---")

        chainTable := NewChainHashTable(10)
        openTable := NewOpenHashTable(10)

        reader := bufio.NewReader(os.Stdin)
        var choice int
        var key, value string

        for </span><span class="cov0" title="0">{
                fmt.Println("\n=== МЕНЮ ХЕШ-ТАБЛИЦ ===")
                fmt.Println("1. Добавить элемент")
                fmt.Println("2. Найти элемент")
                fmt.Println("3. Удалить элемент")
                fmt.Println("4. Показать таблицы")
                fmt.Println("5. Очистить таблицы")
                fmt.Println("6. Изменить размер таблиц")
                fmt.Println("7. Сохранить в файл")
                fmt.Println("8. Загрузить из файла")
                fmt.Println("9. Статистика")
                fmt.Println("0. Вернуться в главное меню")
                fmt.Print("Выберите действие: ")

                fmt.Scanln(&amp;choice)

                switch choice </span>{
                case 1:<span class="cov0" title="0">
                        fmt.Print("Введите ключ: ")
                        key, _ = reader.ReadString('\n')
                        key = strings.TrimSpace(key)

                        fmt.Print("Введите значение: ")
                        value, _ = reader.ReadString('\n')
                        value = strings.TrimSpace(value)

                        chainTable.Insert(key, value)
                        openTable.Insert(key, value)</span>

                case 2:<span class="cov0" title="0">
                        fmt.Print("Введите ключ для поиска: ")
                        key, _ = reader.ReadString('\n')
                        key = strings.TrimSpace(key)

                        chainResult := chainTable.Find(key)
                        openResult := openTable.Find(key)

                        if chainResult != "" </span><span class="cov0" title="0">{
                                fmt.Printf("Цепочечная таблица: %s -&gt; %s\n", key, chainResult)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Цепочечная таблица: ключ '%s' не найден\n", key)
                        }</span>

                        <span class="cov0" title="0">if openResult != "" </span><span class="cov0" title="0">{
                                fmt.Printf("Открытая адресация: %s -&gt; %s\n", key, openResult)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Открытая адресация: ключ '%s' не найден\n", key)
                        }</span>

                case 3:<span class="cov0" title="0">
                        fmt.Print("Введите ключ для удаления: ")
                        key, _ = reader.ReadString('\n')
                        key = strings.TrimSpace(key)

                        chainTable.Remove(key)
                        openTable.Remove(key)</span>

                case 4:<span class="cov0" title="0">
                        chainTable.Display()
                        openTable.Display()</span>

                case 5:<span class="cov0" title="0">
                        chainTable.Clear()
                        openTable.Clear()
                        fmt.Println("Обе таблицы очищены")</span>

                case 6:<span class="cov0" title="0">
                        var newSize int
                        fmt.Print("Введите новый размер таблиц: ")
                        fmt.Scanln(&amp;newSize)

                        if newSize &gt; 0 </span><span class="cov0" title="0">{
                                chainTable.Resize(newSize)
                                openTable.Resize(newSize)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Размер должен быть положительным числом")
                        }</span>

                case 7:<span class="cov0" title="0">
                        chainTable.SaveToFile("chain_hash_interactive.txt")
                        openTable.SaveToFile("open_hash_interactive.txt")</span>

                case 8:<span class="cov0" title="0">
                        chainTable.LoadFromFile("chain_hash_interactive.txt")
                        openTable.LoadFromFile("open_hash_interactive.txt")</span>

                case 9:<span class="cov0" title="0">
                        fmt.Println("\n--- СТАТИСТИКА ---")
                        fmt.Println("Цепочечная таблица:")
                        fmt.Printf("  Емкость таблицы: %d\n", chainTable.GetCapacity())
                        fmt.Printf("  Количество элементов: %d\n", chainTable.GetSize())
                        fmt.Printf("  Заполнение: %d/%d элементов\n",
                                chainTable.GetSize(), chainTable.GetCapacity())

                        fmt.Println("\nОткрытая адресация:")
                        fmt.Printf("  Емкость таблицы: %d\n", openTable.GetCapacity())
                        fmt.Printf("  Количество элементов: %d\n", openTable.GetSize())
                        fmt.Printf("  Коэффициент заполнения: %.1f%%\n",
                                openTable.GetLoadFactor()*100)</span>

                case 0:<span class="cov0" title="0">
                        fmt.Println("Возврат в главное меню")
                        return</span>

                default:<span class="cov0" title="0">
                        fmt.Println("Неверный выбор. Попробуйте снова.")</span>
                }
        }
}

// Main - главная функция
func main() <span class="cov0" title="0">{
        fmt.Println("ДЕМОНСТРАЦИЯ РЕАЛИЗАЦИИ СТРУКТУР ДАННЫХ НА GO")

        var choice int

        for </span><span class="cov0" title="0">{
                fmt.Println("\n--- ГЛАВНОЕ МЕНЮ ---")
                fmt.Println("1. Полное бинарное дерево")
                fmt.Println("2. Односвязный список")
                fmt.Println("3. Двусвязный список")
                fmt.Println("4. Динамический массив")
                fmt.Println("5. Очередь")
                fmt.Println("6. Стек")
                fmt.Println("7. Хеш-таблицы (демонстрация)")
                fmt.Println("8. Хеш-таблицы (интерактивный режим)")
                fmt.Println("9. Бинарная сериализация")
                fmt.Println("10. Все виды сериализации")
                fmt.Println("11. Все структуры данных")
                fmt.Println("0. Выход")
                fmt.Print("Выберите вариант: ")

                fmt.Scanln(&amp;choice)

                switch choice </span>{
                case 1:<span class="cov0" title="0">
                        demonstrateFullBinaryTree()</span>
                case 2:<span class="cov0" title="0">
                        demonstrateSinglyLinkedList()</span>
                case 3:<span class="cov0" title="0">
                        demonstrateDoublyLinkedList()</span>
                case 4:<span class="cov0" title="0">
                        demonstrateDynamicArray()</span>
                case 5:<span class="cov0" title="0">
                        demonstrateQueue()</span>
                case 6:<span class="cov0" title="0">
                        demonstrateStack()</span>
                case 7:<span class="cov0" title="0">
                        demonstrateHashTable()</span>
                case 8:<span class="cov0" title="0">
                        demonstrateHashTableInteractive()</span>
                case 9:<span class="cov0" title="0">
                        demonstrateBinarySerialization()</span>
                case 10:<span class="cov0" title="0">
                        demonstrateAllSerialization()</span>
                case 11:<span class="cov0" title="0">
                        demonstrateFullBinaryTree()
                        demonstrateSinglyLinkedList()
                        demonstrateDoublyLinkedList()
                        demonstrateDynamicArray()
                        demonstrateQueue()
                        demonstrateStack()
                        demonstrateHashTable()</span>
                case 0:<span class="cov0" title="0">
                        fmt.Println("Выход из программы.")
                        return</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Неверный выбор!")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "os"
        "strconv"
)

// Queue - очередь на кольцевом буфере
type Queue struct {
        arr         []int
        capacity    int
        frontIdx    int
        rearIdx     int
        currentSize int
}

// NewQueue - конструктор
func NewQueue() *Queue <span class="cov8" title="1">{
        q := &amp;Queue{
                arr:         make([]int, 4),
                capacity:    4,
                frontIdx:    0,
                rearIdx:     0,
                currentSize: 0,
        }
        return q
}</span>

// resize - изменение размера
func (q *Queue) resize() <span class="cov8" title="1">{
        newCapacity := q.capacity * 2
        newArr := make([]int, newCapacity)

        i := 0
        j := q.frontIdx
        for i &lt; q.currentSize </span><span class="cov8" title="1">{
                newArr[i] = q.arr[j]
                j = (j + 1) % q.capacity
                i++
        }</span>

        <span class="cov8" title="1">q.arr = newArr
        q.capacity = newCapacity
        q.frontIdx = 0
        q.rearIdx = q.currentSize</span>
}

// Push - добавление элемента
func (q *Queue) Push(value int) <span class="cov8" title="1">{
        if q.currentSize == q.capacity </span><span class="cov8" title="1">{
                q.resize()
        }</span>

        <span class="cov8" title="1">q.arr[q.rearIdx] = value
        q.rearIdx = (q.rearIdx + 1) % q.capacity
        q.currentSize++

        fmt.Printf("Добавлен элемент: %d\n", value)</span>
}

// Pop - удаление элемента
func (q *Queue) Pop() <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                fmt.Println("Очередь пуста! Нельзя удалить элемент.")
                return
        }</span>

        <span class="cov8" title="1">frontValue := q.arr[q.frontIdx]
        q.frontIdx = (q.frontIdx + 1) % q.capacity
        q.currentSize--

        fmt.Printf("Удален элемент: %d\n", frontValue)</span>
}

// Front - получение первого элемента
func (q *Queue) Front() int <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                fmt.Println("Очередь пуста!")
                return -1
        }</span>
        <span class="cov8" title="1">return q.arr[q.frontIdx]</span>
}

// IsEmpty - проверка на пустоту
func (q *Queue) IsEmpty() bool <span class="cov8" title="1">{
        return q.currentSize == 0
}</span>

// Size - получение размера
func (q *Queue) Size() int <span class="cov8" title="1">{
        return q.currentSize
}</span>

// Display - отображение очереди
func (q *Queue) Display() <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                fmt.Println("Очередь пуста!")
                return
        }</span>

        <span class="cov8" title="1">fmt.Print("Содержимое очереди: ")
        idx := q.frontIdx
        for i := 0; i &lt; q.currentSize; i++ </span><span class="cov8" title="1">{
                fmt.Printf("%d ", q.arr[idx])
                idx = (idx + 1) % q.capacity
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// Clear - очистка очереди
func (q *Queue) Clear() <span class="cov8" title="1">{
        q.frontIdx = 0
        q.rearIdx = 0
        q.currentSize = 0
        fmt.Println("Очередь очищена!")
}</span>

// SaveToFile - сохранение в текстовый файл
func (q *Queue) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        idx := q.frontIdx
        for i := 0; i &lt; q.currentSize; i++ </span><span class="cov8" title="1">{
                _, err := fmt.Fprintf(file, "%d ", q.arr[idx])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">idx = (idx + 1) % q.capacity</span>
        }

        <span class="cov8" title="1">fmt.Printf("Очередь сохранена в файл: %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (q *Queue) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        q.Clear()

        scanner := bufio.NewScanner(file)
        scanner.Split(bufio.ScanWords)

        for scanner.Scan() </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(scanner.Text())
                if err == nil </span><span class="cov8" title="1">{
                        q.Push(value)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Очередь загружена из файла: %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл
func (q *Queue) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        queueSize := int64(q.currentSize)
        err = binary.Write(file, binary.LittleEndian, queueSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">idx := q.frontIdx
        for i := 0; i &lt; q.currentSize; i++ </span><span class="cov8" title="1">{
                err = binary.Write(file, binary.LittleEndian, int32(q.arr[idx]))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">idx = (idx + 1) % q.capacity</span>
        }

        <span class="cov8" title="1">fmt.Printf("Очередь сохранена в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла
func (q *Queue) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        q.Clear()

        var queueSize int64
        err = binary.Read(file, binary.LittleEndian, &amp;queueSize)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(queueSize); i++ </span><span class="cov8" title="1">{
                var value int32
                err = binary.Read(file, binary.LittleEndian, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">q.Push(int(value))</span>
        }

        <span class="cov8" title="1">fmt.Printf("Очередь загружена из бинарного файла: %s\n", filename)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "os"
        "strconv"
)

// Node - узел односвязного списка
type Node struct {
        Key  int
        Next *Node
}

// SinglyLinkedList - односвязный список
type SinglyLinkedList struct {
        Head *Node
}

// NewSinglyLinkedList - конструктор
func NewSinglyLinkedList() *SinglyLinkedList <span class="cov8" title="1">{
        return &amp;SinglyLinkedList{
                Head: nil,
        }
}</span>

// createNode - создание нового узла
func (s *SinglyLinkedList) createNode(value int) *Node <span class="cov8" title="1">{
        return &amp;Node{
                Key:  value,
                Next: nil,
        }
}</span>

// AddToHead - добавление в начало
func (s *SinglyLinkedList) AddToHead(value int) <span class="cov8" title="1">{
        newNode := s.createNode(value)
        newNode.Next = s.Head
        s.Head = newNode
        fmt.Printf("Добавлен в начало: %d\n", value)
}</span>

// AddToTail - добавление в конец
func (s *SinglyLinkedList) AddToTail(value int) <span class="cov8" title="1">{
        newNode := s.createNode(value)

        if s.Head == nil </span><span class="cov8" title="1">{
                s.Head = newNode
                fmt.Printf("Добавлен в конец: %d\n", value)
                return
        }</span>

        <span class="cov8" title="1">current := s.Head
        for current.Next != nil </span><span class="cov8" title="1">{
                current = current.Next
        }</span>
        <span class="cov8" title="1">current.Next = newNode
        fmt.Printf("Добавлен в конец: %d\n", value)</span>
}

// AddAfter - добавление после значения
func (s *SinglyLinkedList) AddAfter(targetValue, newValue int) <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>

        <span class="cov8" title="1">current := s.Head
        for current != nil &amp;&amp; current.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov8" title="1">{
                fmt.Printf("%d не найден!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">newNode := s.createNode(newValue)
        newNode.Next = current.Next
        current.Next = newNode
        fmt.Printf("Добавлен после %d: %d\n", targetValue, newValue)</span>
}

// AddBefore - добавление перед значением
func (s *SinglyLinkedList) AddBefore(targetValue, newValue int) <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>

        <span class="cov8" title="1">if s.Head.Key == targetValue </span><span class="cov8" title="1">{
                s.AddToHead(newValue)
                return
        }</span>

        <span class="cov8" title="1">current := s.Head
        for current.Next != nil &amp;&amp; current.Next.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current.Next == nil </span><span class="cov8" title="1">{
                fmt.Printf("%d не найден!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">newNode := s.createNode(newValue)
        newNode.Next = current.Next
        current.Next = newNode
        fmt.Printf("Добавлен перед %d: %d\n", targetValue, newValue)</span>
}

// DeleteBefore - удаление перед значением
func (s *SinglyLinkedList) DeleteBefore(targetValue int) <span class="cov8" title="1">{
        if s.Head == nil || s.Head.Next == nil </span><span class="cov8" title="1">{
                fmt.Println("Недостаточно элементов для удаления!")
                return
        }</span>

        <span class="cov8" title="1">if s.Head.Key == targetValue </span><span class="cov8" title="1">{
                fmt.Println("Невозможно удалить элемент перед первым элементом!")
                return
        }</span>

        <span class="cov8" title="1">if s.Head.Next.Key == targetValue </span><span class="cov8" title="1">{
                temp := s.Head
                s.Head = s.Head.Next
                fmt.Printf("Удален элемент: %d перед элементом %d\n", temp.Key, targetValue)
                return
        }</span>

        <span class="cov8" title="1">current := s.Head
        for current.Next.Next != nil &amp;&amp; current.Next.Next.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current.Next.Next == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d не найден!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">nodeToDelete := current.Next
        current.Next = current.Next.Next
        fmt.Printf("Удален элемент: %d перед элементом %d\n", nodeToDelete.Key, targetValue)</span>
}

// DeleteAfter - удаление после значения
func (s *SinglyLinkedList) DeleteAfter(targetValue int) <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст! Невозможно удалить элемент.")
                return
        }</span>

        <span class="cov8" title="1">current := s.Head
        for current != nil &amp;&amp; current.Key != targetValue </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d не найден в списке!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">if current.Next == nil </span><span class="cov8" title="1">{
                fmt.Printf("После элемента %d нет элементов для удаления!\n", targetValue)
                return
        }</span>

        <span class="cov8" title="1">nodeToDelete := current.Next
        current.Next = current.Next.Next
        fmt.Printf("Удален элемент: %d после элемента %d\n", nodeToDelete.Key, targetValue)</span>
}

// Print - печать списка
func (s *SinglyLinkedList) Print() <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">current := s.Head
        for current != nil </span><span class="cov8" title="1">{
                fmt.Printf("%d -&gt; ", current.Key)
                current = current.Next
        }</span>
        <span class="cov8" title="1">fmt.Println("nullptr")</span>
}

// PrintReverse - печать в обратном порядке
func (s *SinglyLinkedList) PrintReverse() <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>

        <span class="cov8" title="1">stack := []int{}
        current := s.Head

        for current != nil </span><span class="cov8" title="1">{
                stack = append(stack, current.Key)
                current = current.Next
        }</span>

        <span class="cov8" title="1">fmt.Print("Список в обратном порядке: ")
        for i := len(stack) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                fmt.Printf("%d -&gt; ", stack[i])
        }</span>
        <span class="cov8" title="1">fmt.Println("nullptr")</span>
}

// DeleteFromHead - удаление из начала
func (s *SinglyLinkedList) DeleteFromHead() <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>
        <span class="cov8" title="1">temp := s.Head
        s.Head = s.Head.Next
        fmt.Printf("Удален из начала: %d\n", temp.Key)</span>
}

// DeleteFromTail - удаление из конца
func (s *SinglyLinkedList) DeleteFromTail() <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>

        <span class="cov8" title="1">if s.Head.Next == nil </span><span class="cov8" title="1">{
                fmt.Printf("Удален из конца: %d\n", s.Head.Key)
                s.Head = nil
                return
        }</span>

        <span class="cov8" title="1">current := s.Head
        for current.Next.Next != nil </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">temp := current.Next
        current.Next = nil
        fmt.Printf("Удален из конца: %d\n", temp.Key)</span>
}

// DeleteByValue - удаление по значению
func (s *SinglyLinkedList) DeleteByValue(value int) <span class="cov8" title="1">{
        if s.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>

        // Удаление головы
        <span class="cov8" title="1">if s.Head.Key == value </span><span class="cov8" title="1">{
                temp := s.Head
                s.Head = s.Head.Next
                fmt.Printf("Удален элемент: %d\n", temp.Key)
                return
        }</span>

        // Удаление не головы
        <span class="cov8" title="1">current := s.Head
        var prev *Node

        for current != nil &amp;&amp; current.Key != value </span><span class="cov8" title="1">{
                prev = current
                current = current.Next
        }</span>

        <span class="cov8" title="1">if current == nil </span><span class="cov0" title="0">{
                fmt.Printf("Элемент %d не найден!\n", value)
                return
        }</span>

        <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                prev.Next = current.Next
        }</span>

        <span class="cov8" title="1">fmt.Printf("Удален элемент: %d\n", current.Key)</span>
}

// FindByValue - поиск по значению
func (s *SinglyLinkedList) FindByValue(value int) bool <span class="cov8" title="1">{
        current := s.Head
        for current != nil </span><span class="cov8" title="1">{
                if current.Key == value </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Clear - очистка списка
func (s *SinglyLinkedList) Clear() <span class="cov8" title="1">{
        s.Head = nil
}</span>

// SaveToFile - сохранение в текстовый файл
func (s *SinglyLinkedList) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка создания файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        current := s.Head
        for current != nil </span><span class="cov8" title="1">{
                _, err := fmt.Fprintf(file, "%d ", current.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        <span class="cov8" title="1">fmt.Printf("Односвязный список сохранён в файл: %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (s *SinglyLinkedList) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        s.Clear()

        scanner := bufio.NewScanner(file)
        scanner.Split(bufio.ScanWords)

        for scanner.Scan() </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(scanner.Text())
                if err == nil </span><span class="cov8" title="1">{
                        s.AddToTail(value)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Односвязный список загружен из файла: %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл
func (s *SinglyLinkedList) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия бинарного файла для записи: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        count := 0
        current := s.Head
        for current != nil </span><span class="cov8" title="1">{
                count++
                current = current.Next
        }</span>

        <span class="cov8" title="1">err = binary.Write(file, binary.LittleEndian, int32(count))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">current = s.Head
        for current != nil </span><span class="cov8" title="1">{
                err = binary.Write(file, binary.LittleEndian, int32(current.Key))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        <span class="cov8" title="1">fmt.Printf("Односвязный список сохранён в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла
func (s *SinglyLinkedList) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла для чтения: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        s.Clear()

        var count int32
        err = binary.Read(file, binary.LittleEndian, &amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(count); i++ </span><span class="cov8" title="1">{
                var value int32
                err = binary.Read(file, binary.LittleEndian, &amp;value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">s.AddToTail(int(value))</span>
        }

        <span class="cov8" title="1">fmt.Printf("Односвязный список загружен из бинарного файла: %s\n", filename)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "os"
        "strconv"
)

const MAX_SIZE = 100

// Stack - стек на массиве
type Stack struct {
        data   [MAX_SIZE]int
        topIdx int
}

// NewStack - конструктор
func NewStack() *Stack <span class="cov8" title="1">{
        return &amp;Stack{
                topIdx: -1,
        }
}</span>

// Push - добавление элемента
func (s *Stack) Push(value int) <span class="cov8" title="1">{
        if s.topIdx &gt;= MAX_SIZE-1 </span><span class="cov8" title="1">{
                fmt.Println("Стек переполнен!")
                return
        }</span>
        <span class="cov8" title="1">s.topIdx++
        s.data[s.topIdx] = value</span>
}

// Pop - удаление элемента
func (s *Stack) Pop() int <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                fmt.Println("Стек пуст!")
                return -1
        }</span>
        <span class="cov8" title="1">value := s.data[s.topIdx]
        s.topIdx--
        return value</span>
}

// Peek - получение верхнего элемента
func (s *Stack) Peek() int <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return s.data[s.topIdx]</span>
}

// IsEmpty - проверка на пустоту
func (s *Stack) IsEmpty() bool <span class="cov8" title="1">{
        return s.topIdx == -1
}</span>

// Size - получение размера
func (s *Stack) Size() int <span class="cov8" title="1">{
        return s.topIdx + 1
}</span>

// Print - печать стека
func (s *Stack) Print() <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                fmt.Println("Стек пуст!")
                return
        }</span>
        <span class="cov8" title="1">fmt.Print("Стек (сверху вниз): ")
        for i := s.topIdx; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                fmt.Printf("%d ", s.data[i])
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

// Clear - очистка стека
func (s *Stack) Clear() <span class="cov8" title="1">{
        s.topIdx = -1
}</span>

// SaveToFile - сохранение в текстовый файл
func (s *Stack) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        for i := 0; i &lt;= s.topIdx; i++ </span><span class="cov8" title="1">{
                _, err := fmt.Fprintf(file, "%d ", s.data[i])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Стек сохранен в файл: %s\n", filename)
        return nil</span>
}

// LoadFromFile - загрузка из текстового файла
func (s *Stack) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        s.Clear()

        scanner := bufio.NewScanner(file)
        scanner.Split(bufio.ScanWords)

        for scanner.Scan() </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(scanner.Text())
                if err == nil </span><span class="cov8" title="1">{
                        s.Push(value)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Стек загружен из файла: %s\n", filename)
        return scanner.Err()</span>
}

// SaveToBinaryFile - сохранение в бинарный файл
func (s *Stack) SaveToBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка открытия бинарного файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        stackSize := int32(s.Size())
        err = binary.Write(file, binary.LittleEndian, stackSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt;= s.topIdx; i++ </span><span class="cov8" title="1">{
                err = binary.Write(file, binary.LittleEndian, int32(s.data[i]))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("Стек сохранен в бинарный файл: %s\n", filename)
        return nil</span>
}

// LoadFromBinaryFile - загрузка из бинарного файла
func (s *Stack) LoadFromBinaryFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Ошибка открытия бинарного файла: %s\n", filename)
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        s.Clear()

        var stackSize int32
        err = binary.Read(file, binary.LittleEndian, &amp;stackSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(stackSize); i++ </span><span class="cov8" title="1">{
                var value int32
                err = binary.Read(file, binary.LittleEndian, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">s.Push(int(value))</span>
        }

        <span class="cov8" title="1">fmt.Printf("Стек загружен из бинарного файла: %s\n", filename)
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
